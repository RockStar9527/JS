==用于一般比较，===用于严格比较，==在比较的时候可以转换数据类型，===严格比较，只要类型不匹配就返回flase。

举例说明：

"1" == true类型不同，"=="将先做类型转换，把true转换为1，即为 "1" == 1；此时，类型仍不同，继续进行类型转换，把"1"转换为1，即为 1 == 1。

1.如果比较："1" === true 左侧为字符型，右侧为bool布尔型或int数值型，左右两侧类型不同，结果为false；



1.isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。
2.函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。

tcp和udp的区别有：1、udp是无连接的，tcp是面向连接的；2、udp是不可靠传输，tcp是可靠传输；3、udp是面向报文传输，tcp是面向字节流传输。

## 2 运算符

### 2.1 运算符和表达式

#### ① 运算符

```
1. 运算符就是用于运算的符号， 像+、-、*、/ 等。
2. 与运算符一起运算的数据（变量或者直接量或者表达式）称之为操作数。
```

#### ② 表达式

```
1. 由运算符与数据组成的式子，称之为表达式； 表达式有一个计算结果，称为表达式的值。
2. 最简单的表达式叫“原始表达式”，一个变量、一个直接量。
3. 多个简单的表达式可以组成一个复杂的表达式。
4. 有些表达式具有副作用，副作用指的是会改变参与运算的变量； 副作用由运算符决定。
```

### 2.2 运算符的分类

#### ① 按照运算符需要的操作数的个数

```
一元运算符（一目运算符）
二元运算符（二目运算符）
三元运算符（三目运算符）
```

#### ② 按照运算符的功能

```
1. 算术运算符
2. 关系运算符
3. 逻辑运算符
4. 位运算符
5. 赋值运算符
6. 其他运算符
```

### 2.3 运算符讲解（按照功能）

#### ① 算术运算符

| 运算符 | 含义         | 操作数个数 | 操作数的类型要求 | 组成的表达式的值的类型 | 有无副作用 |
| ------ | ------------ | ---------- | ---------------- | ---------------------- | ---------- |
| +      | 加号         | 2          | number           | number                 | 无         |
| -      | 减号         | 2          | number           | number                 | 无         |
| *      | 乘号         | 2          | number           | number                 | 无         |
| /      | 除号         | 2          | number           | number                 | 无         |
| %      | 取余（取模） | 2          | number           | number                 | 无         |
| +      | 正号         | 1          | number           | number                 | 无         |
| -      | 负号         | 1          | number           | number                 | 无         |
| ++     | 累加         | 1          | number           | number                 | 有         |
| --     | 累减         | 1          | number           | number                 | 有         |

> **正号运算符的作用：**
>
> 通常，可以利用正号运算符把其他数据类型转为 number，利用了数据类型自动转换的原理。
>
> 效果与使用 Number() 函数是一样的。

> **累加和累减运算符：**
>
> 1. 累加和累减运算符都有副作用，要求操作数必须以变量的形式给出。
>
> 2. 累加和累减运算符可以在操作数的前面，也可以在操作数的后面； 
>
>    运算符不论在前还是在后产生的副作用都是一样的。 
>
>    运算符在前还是在后，表达式的值是不一样的。
>
>    ```
>    ① 运算符在前： 如 ++n,  取n累加之后的值作为表达式的值。
>    ② 运算符在后： 如 n++， 取n累加之前的值作为表达式的值。
>    ```

#### ② 关系运算符（比较运算符）

| 运算符 | 含义     | 操作数个数 | 操作数的类型要求 | 组成的表达式的值的类型 | 有无副作用 |
| ------ | -------- | ---------- | ---------------- | ---------------------- | ---------- |
| >      | 大于     | 2          | number、string   | boolean                | 无         |
| >=     | 大于等于 | 2          | number、string   | boolean                | 无         |
| <      | 小于     | 2          | number、string   | boolean                | 无         |
| <=     | 小于等于 | 2          | number、string   | boolean                | 无         |
| ==     | 相等     | 2          | number、string   | boolean                | 无         |
| !=     | 不相等   | 2          | number、string   | boolean                | 无         |
| ===    | 全等     | 2          | 没有要求         | boolean                | 无         |
| !==    | 不全等   | 2          | 没有要求         | boolean                | 无         |

> **比较大小的规则如下：**
>
> 1. 如果两个操作数类型不一致，转为 number 之后才进行比较。
> 2. NaN 与任何数据进行任何比较得到都是 false。
> 3. 如果两个操作数都是字符串，会按照字符串的比较规则进行比较。
>
> **字符串比较大小的规则：**
>
> 1. 字符串按每位字符比较。
> 2. 取每个字符的unicode 编码比较大小。
>
> **判断相等（==） 和不相等（!=）的规则：**
>
> 1. 如果两个操作数类型不一致，转为 number 之后才进行比较。
> 2. NaN 与任何数据都不相等，包括自己。
> 3. 如果两个操作数都是字符串，会使用字符串的比较规则进行比较：两个字符串完全一致就相等。
>
> **null 与其他类型的数据进行判断相等操作，具有自己的特殊规则：**
>
> ```js
> null == '';   // false
> null == false; // false
> null == 0;    // false
> null == undefeind;  // true 
> ```
>
> **判断全等（===）和不全等（!==）的规则：**
>
> 1. 如果两个操作数类型不一致，直接全等不成立。
> 2. 两个操作数类型一致且值相同才能全等成立。
> 3. 全等与相等相比，不会发生数据类型的自动转换。

#### ③ 逻辑运算符

| 运算符 | 含义           | 操作数个数 | 操作数的类型要求 | 组成的表达式的值的类型             | 有无副作用 |
| ------ | -------------- | ---------- | ---------------- | ---------------------------------- | ---------- |
| &&     | 逻辑与（并且） | 2          | 没有要求         | 取其中一个操作数的值作为表达式的值 | 无         |
| \|\|   | 逻辑或（或者） | 2          | 没有要求         | 取其中一个操作数的值作为表达式的值 | 无         |
| !      | 逻辑非         | 1          | boolean          | boolean                            | 无         |

> **逻辑与组成的表达式的取值规则如下：**
>
> 1. 如果第一个操作数成立，取第二个操作数的值作为表达式的值。
> 2. 如果第一个操作数不成立，取第一个操作数的值作为表达式的值。
>
> **逻辑或组成的表达式的取值规则如下：**
>
> 1. 如果第一个操作数成立，取第一个操作数作为表达式的值。
> 2. 如果第一个操作数不成立，取第二个操作数作为表达式的值。

#### ④ 赋值运算符

| 运算符 | 含义           | 操作数个数 | 操作数的类型要求 | 组成的表达式的值的类型 | 有无副作用 |
| ------ | -------------- | ---------- | ---------------- | ---------------------- | ---------- |
| =      | 赋值           | 2          | 无               | 多种可能               | 有         |
| +=     | 求和赋值       | 2          | number           | number                 | 有         |
| -=     | 求差赋值       | 2          | number           | numbe                  | 有         |
| *=     | 求积赋值       | 2          | number           | numbe                  | 有         |
| /=     | 求商赋值       | 2          | numbe            | numbe                  | 有         |
| %=     | 求余赋值       | 2          | numbe            | numbe                  | 有         |
| +=     | 字符串连接赋值 | 2          | string           | string                 | 有         |

> **总结：**
>
> 1. 赋值运算符组成的表达式的值是左边的变量赋值之后的值， 但是赋值运算符我们主要用的副作用。
> 2. 赋值运算符左边的操作数必须是变量的形式，右边的操作数可以是变量、直接量、表达式各种形式。

#### ⑤ 其他运算符

| 运算符 | 含义         | 操作数个数 | 操作数的类型要求 | 组成的表达式的值的类型 | 有无副作用 |
| ------ | ------------ | ---------- | ---------------- | ---------------------- | ---------- |
| +      | 字符串连接符 | 2          | string           | string                 | 无         |
| typeof | 数据类型判断 | 1          | 无               | string                 | 无         |
| ,      | 逗号运算符   | 2          | 无               |                        | 无         |
| ?:     | 比较运算符   | 3          | 无               | 不一定                 | 无         |

> **`+` 到底是什么运算符？**
>
> 1. 如果操作数个数只有一个，`+` 是正号运算符。
> 2. 如果操作数个数有2个，且至少有个操作数是字符串，`+` 是字符串连接符。
> 3. 如果操作数格式有2个，操作数中没有字符串，`+`是加号运算符。
>
> ，运算符JS只出现在多个变量赋值
>
> **`?:` 运算符总结：**
>
> 1. 该运算符是 JS 中唯一的三元运算符
> 2. 所组成的表达式的值取第二个操作数的值或者是第三个操作数的值：  如果第一个操作数成立取第二个操作数作为表达式的值；如果第一个操作数不成立取第三个操作数的值作为表达式的值。

### 2.4 运算符优先级

```
1. 一元运算符   ++、--、-、+、!、typeof 等
2. 算术运算符  *、/、% 大于 +、-
3. 关系运算符
4. 逻辑运算符
5. ?:
6. 赋值运算符
```

> **注意：** 可以通过添加 () 提高运算符优先级。



## 3 分支结构 （条件语句）

### 3.1 单向分支

```js
if (条件表达式) {
    语句 ...;
}
```

### 3.2 双向分支

```
if (条件表达式) {
	语句 ...;
} else {
	语句 ...;
}
```

### 3.3 多向分支 else if

```js
if (条件表达式) {
    语句 ...;
} else if (条件表达式) {
    语句 ...;
} else if (条件表达式) {
    语句 ...;
} else if (条件表达式) {
    语句 ...;
} else {
    语句 ...;
}
```

### 3.4 多向分支 switch case

```js
switch (表达式) {
	case 表达式可能的值： 语句...; break;    
    case 表达式可能的值： 语句...; break;
	case 表达式可能的值： 语句...; break;    
    case 表达式可能的值： 语句...; break;
    case 表达式可能的值： 语句...; break;
    default: 语句...;
}
```

> **总结：**
>
> 1. 表达式和case后面的值使用全等规则进行判等。
> 2. case 后面的语句可以与 case 写在一行，也可以另起一行（另起一行的时候要缩进）。
> 3. `break` 可以结束当前 case，如果没有 `break` 会一直向下执行直到遇到 break 或结束。

### 3.5 嵌套分支

```js
if (条件表达式) {
    if (条件表达式) {
        
    }
} else {
    if (条件表达式) {
        
    } else {
        
    }
}
```



